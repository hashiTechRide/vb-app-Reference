# ステートレスとトランザクションスクリプト完全ガイド (VB.NET)

## 目次
1. [ステートレス (Stateless)](#ステートレス-stateless)
2. [トランザクションスクリプト (Transaction Script)](#トランザクションスクリプト-transaction-script)
3. [トランザクションスクリプトの問題と解決策](#トランザクションスクリプトの問題と解決策)

---

## ステートレス (Stateless)

### 概要
**ステートレス**とは、オブジェクトやメソッドが**内部状態を保持しない**設計手法です。同じ入力に対して常に同じ出力を返すため、予測可能で安全なコードになります。

### 基本概念の比較

#### ❌ ステートフル（状態を持つ）- 避けるべき例

```vb.net
Public Class OrderCalculatorStateful
    ' ⚠️ 内部状態を保持 - 問題あり
    Private currentDiscount As Decimal = 0
    Private currentTaxRate As Decimal = 0
    
    Public Sub SetDiscount(discount As Decimal)
        Me.currentDiscount = discount
    End Sub
    
    Public Sub SetTaxRate(taxRate As Decimal)
        Me.currentTaxRate = taxRate
    End Sub
    
    Public Function CalculateTotal(amount As Decimal) As Decimal
        ' ⚠️ 内部状態に依存 - メソッドの呼び出し順序に影響される
        Dim afterDiscount = amount * (1 - currentDiscount)
        Return afterDiscount * (1 + currentTaxRate)
    End Function
End Class
```

**問題点:**
```vb.net
Dim calc As New OrderCalculatorStateful()

' 最初の計算
calc.SetDiscount(0.1)  ' 10%割引
calc.SetTaxRate(0.08)  ' 8%税率
Dim total1 = calc.CalculateTotal(1000)  ' 結果: 972円

' 別の処理で状態が変更される
calc.SetDiscount(0.2)  ' 20%割引に変更

' ⚠️ 意図しない結果になる
Dim total2 = calc.CalculateTotal(1000)  ' 結果: 864円（期待: 972円）

' マルチスレッド環境では更に危険
Task.Run(Sub() calc.SetDiscount(0.5))  ' 他スレッドで状態変更
Dim total3 = calc.CalculateTotal(1000)  ' 予測不可能な結果
```

#### ✅ ステートレス - 推奨される例

```vb.net
Public Class OrderCalculatorStateless
    ' ✅ 内部状態なし - すべて引数で受け取る
    Public Function CalculateTotal(amount As Decimal, 
                                   discount As Decimal, 
                                   taxRate As Decimal) As Decimal
        Dim afterDiscount = amount * (1 - discount)
        Return afterDiscount * (1 + taxRate)
    End Function
    
    ' オーバーロードで柔軟性を提供
    Public Function CalculateTotal(amount As Decimal, 
                                   taxRate As Decimal) As Decimal
        Return amount * (1 + taxRate)
    End Function
    
    ' デフォルト値を使った便利メソッド
    Public Function CalculateTotalWithDefaultTax(amount As Decimal, 
                                                 discount As Decimal) As Decimal
        Const DEFAULT_TAX_RATE As Decimal = 0.1  ' 10%
        Return CalculateTotal(amount, discount, DEFAULT_TAX_RATE)
    End Function
End Class
```

**利点:**
```vb.net
Dim calc As New OrderCalculatorStateless()

' ✅ 常に予測可能
Dim total1 = calc.CalculateTotal(1000, 0.1, 0.08)  ' 972円
Dim total2 = calc.CalculateTotal(1000, 0.1, 0.08)  ' 972円（常に同じ）
Dim total3 = calc.CalculateTotal(1000, 0.2, 0.08)  ' 864円

' ✅ マルチスレッドでも安全
Parallel.For(0, 100, Sub(i)
    Dim result = calc.CalculateTotal(1000, 0.1, 0.08)
    ' 全て972円で一致
End Sub)

' ✅ テストが簡単
Assert.AreEqual(972, calc.CalculateTotal(1000, 0.1, 0.08))
```

### 実践的な例: データベースアクセス

#### ❌ ステートフル - 問題のある設計

```vb.net
Public Class UserRepositoryStateful
    Private ReadOnly connectionString As String
    Private currentUserId As Integer  ' ⚠️ 状態を保持
    Private currentUser As User       ' ⚠️ 状態を保持
    
    Public Sub New(connString As String)
        Me.connectionString = connString
    End Sub
    
    Public Sub LoadUser(userId As Integer)
        Me.currentUserId = userId
        ' データベースから取得
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand("SELECT * FROM Users WHERE UserId = @Id", conn)
                cmd.Parameters.AddWithValue("@Id", userId)
                conn.Open()
                Using reader = cmd.ExecuteReader()
                    If reader.Read() Then
                        currentUser = New User With {
                            .UserId = Convert.ToInt32(reader("UserId")),
                            .UserName = reader("UserName").ToString(),
                            .Email = reader("Email").ToString()
                        }
                    End If
                End Using
            End Using
        End Using
    End Sub
    
    Public Function GetUserName() As String
        ' ⚠️ 事前にLoadUserを呼ぶ必要がある
        If currentUser Is Nothing Then
            Throw New InvalidOperationException("先にLoadUserを呼んでください")
        End If
        Return currentUser.UserName
    End Function
    
    Public Function GetEmail() As String
        ' ⚠️ 同じ問題
        If currentUser Is Nothing Then
            Throw New InvalidOperationException("先にLoadUserを呼んでください")
        End If
        Return currentUser.Email
    End Function
End Class
```

**問題点:**
```vb.net
Dim repo As New UserRepositoryStateful(connString)

' ⚠️ 呼び出し順序に依存
Try
    Dim name = repo.GetUserName()  ' エラー！LoadUserを呼んでいない
Catch ex As InvalidOperationException
    Console.WriteLine(ex.Message)
End Try

' 正しい順序で呼ぶ必要がある
repo.LoadUser(1)
Dim name1 = repo.GetUserName()  ' "山田太郎"

' ⚠️ 別のユーザーをロードすると以前の情報は消える
repo.LoadUser(2)
Dim name2 = repo.GetUserName()  ' "佐藤花子"（山田太郎の情報は失われた）
```

#### ✅ ステートレス - 推奨される設計

```vb.net
Public Class UserRepositoryStateless
    Private ReadOnly connectionString As String
    
    Public Sub New(connString As String)
        Me.connectionString = connString
    End Sub
    
    ' ✅ ステートレス - 必要な情報を全て引数で受け取る
    Public Function GetUserById(userId As Integer) As User
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand("SELECT * FROM Users WHERE UserId = @Id", conn)
                cmd.Parameters.AddWithValue("@Id", userId)
                conn.Open()
                
                Using reader = cmd.ExecuteReader()
                    If reader.Read() Then
                        Return New User With {
                            .UserId = Convert.ToInt32(reader("UserId")),
                            .UserName = reader("UserName").ToString(),
                            .Email = reader("Email").ToString()
                        }
                    End If
                End Using
            End Using
        End Using
        Return Nothing
    End Function
    
    Public Function GetUsersByDepartment(departmentId As Integer) As List(Of User)
        Dim users As New List(Of User)
        
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand(
                "SELECT * FROM Users WHERE DepartmentId = @DeptId", conn)
                cmd.Parameters.AddWithValue("@DeptId", departmentId)
                conn.Open()
                
                Using reader = cmd.ExecuteReader()
                    While reader.Read()
                        users.Add(New User With {
                            .UserId = Convert.ToInt32(reader("UserId")),
                            .UserName = reader("UserName").ToString(),
                            .Email = reader("Email").ToString()
                        })
                    End While
                End Using
            End Using
        End Using
        
        Return users
    End Function
    
    Public Function GetUserByEmail(email As String) As User
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand(
                "SELECT * FROM Users WHERE Email = @Email", conn)
                cmd.Parameters.AddWithValue("@Email", email)
                conn.Open()
                
                Using reader = cmd.ExecuteReader()
                    If reader.Read() Then
                        Return New User With {
                            .UserId = Convert.ToInt32(reader("UserId")),
                            .UserName = reader("UserName").ToString(),
                            .Email = reader("Email").ToString()
                        }
                    End If
                End Using
            End Using
        End Using
        Return Nothing
    End Function
End Class

Public Class User
    Public Property UserId As Integer
    Public Property UserName As String
    Public Property Email As String
End Class
```

**利点:**
```vb.net
Dim repo As New UserRepositoryStateless(connString)

' ✅ どの順序で呼んでも安全
Dim user1 = repo.GetUserById(1)
Dim user2 = repo.GetUserById(2)
Dim user3 = repo.GetUserById(1)  ' 再度取得可能

' ✅ 複数のユーザー情報を同時に扱える
Dim yamada = repo.GetUserById(1)
Dim sato = repo.GetUserById(2)
Console.WriteLine($"{yamada.UserName}, {sato.UserName}")

' ✅ マルチスレッドでも安全
Parallel.For(1, 100, Sub(i)
    Dim user = repo.GetUserById(i)
    ' 競合なし
End Sub)
```

### ステートレスのメリット・デメリット

| 項目 | 内容 |
|------|------|
| **メリット** | |
| ✅ 予測可能性 | 同じ入力に対して常に同じ出力 |
| ✅ テストしやすさ | 状態管理が不要でテストケースがシンプル |
| ✅ スレッドセーフ | 共有状態がないため競合しない |
| ✅ スケーラビリティ | インスタンスを複数作成しても問題なし |
| ✅ デバッグしやすさ | 状態追跡が不要 |
| **デメリット** | |
| ❌ 引数の増加 | 多くの情報を引数で渡す必要がある |
| ❌ パフォーマンス | キャッシュできない場合は毎回計算/取得が必要 |
| ❌ コード量 | 引数の受け渡しで冗長になる場合がある |

### ステートレス設計のベストプラクティス

```vb.net
' ✅ 1. Pure Function（純粋関数）として設計
Public Class MathHelper
    ' 副作用なし、状態なし
    Public Shared Function CalculateCompoundInterest(
        principal As Decimal,
        rate As Decimal,
        years As Integer) As Decimal
        
        Return principal * Math.Pow(1 + rate, years)
    End Function
End Class

' ✅ 2. 設定値は引数またはコンストラクタで
Public Class EmailSender
    Private ReadOnly smtpServer As String
    Private ReadOnly port As Integer
    
    ' 不変の設定はコンストラクタで
    Public Sub New(server As String, serverPort As Integer)
        Me.smtpServer = server
        Me.port = serverPort
    End Sub
    
    ' 可変の値は引数で
    Public Sub SendEmail(toAddress As String, subject As String, body As String)
        ' メール送信処理（内部状態を変更しない）
    End Sub
End Class

' ✅ 3. 読み取り専用プロパティの活用
Public Class Configuration
    Public ReadOnly Property DatabaseConnection As String
    Public ReadOnly Property ApiTimeout As Integer
    
    Public Sub New(dbConn As String, timeout As Integer)
        Me.DatabaseConnection = dbConn
        Me.ApiTimeout = timeout
    End Sub
End Class
```

---

## トランザクションスクリプト (Transaction Script)

### 概要
**トランザクションスクリプト**は、1つのビジネストランザクション（業務処理）を1つのメソッドで表現するパターンです。処理の流れを手続き型で記述します。

### 基本的な構造

```vb.net
Public Class [サービス名]
    ' 1つのトランザクション = 1つのメソッド
    Public Function [業務処理名]([必要なパラメータ]) As [戻り値]
        ' 1. データ取得
        ' 2. ビジネスルールのチェック
        ' 3. データの更新
        ' 4. 結果の返却
    End Function
End Class
```

### 実例1: 注文処理

```vb.net
Public Class OrderService
    Private ReadOnly connectionString As String
    
    Public Sub New(connString As String)
        Me.connectionString = connString
    End Sub
    
    ''' <summary>
    ''' 注文を作成する
    ''' </summary>
    Public Function PlaceOrder(customerId As Integer, 
                              orderItems As List(Of OrderItem)) As Integer
        
        Using conn As New SqlConnection(connectionString)
            conn.Open()
            Using transaction = conn.BeginTransaction()
                Try
                    ' === ステップ1: 顧客情報の確認 ===
                    Dim customerCmd As New SqlCommand(
                        "SELECT Credit, CreditLimit FROM Customers WHERE CustomerId = @Id",
                        conn, transaction)
                    customerCmd.Parameters.AddWithValue("@Id", customerId)
                    
                    Dim credit As Decimal
                    Dim creditLimit As Decimal
                    
                    Using reader = customerCmd.ExecuteReader()
                        If Not reader.Read() Then
                            Throw New Exception("顧客が見つかりません")
                        End If
                        credit = Convert.ToDecimal(reader("Credit"))
                        creditLimit = Convert.ToDecimal(reader("CreditLimit"))
                    End Using
                    
                    ' === ステップ2: 注文総額の計算 ===
                    Dim totalAmount As Decimal = 0
                    For Each item In orderItems
                        totalAmount += item.Price * item.Quantity
                    Next
                    
                    ' === ステップ3: 在庫チェックと引き当て ===
                    For Each item In orderItems
                        ' 在庫確認
                        Dim stockCmd As New SqlCommand(
                            "SELECT Stock FROM Products WHERE ProductId = @ProductId",
                            conn, transaction)
                        stockCmd.Parameters.AddWithValue("@ProductId", item.ProductId)
                        
                        Dim stock As Integer = Convert.ToInt32(stockCmd.ExecuteScalar())
                        
                        If stock < item.Quantity Then
                            Throw New Exception(
                                $"商品ID {item.ProductId} の在庫が不足しています")
                        End If
                        
                        ' 在庫を減らす
                        Dim updateStockCmd As New SqlCommand(
                            "UPDATE Products SET Stock = Stock - @Quantity " &
                            "WHERE ProductId = @ProductId",
                            conn, transaction)
                        updateStockCmd.Parameters.AddWithValue("@Quantity", item.Quantity)
                        updateStockCmd.Parameters.AddWithValue("@ProductId", item.ProductId)
                        updateStockCmd.ExecuteNonQuery()
                    Next
                    
                    ' === ステップ4: クレジット確認 ===
                    If credit < totalAmount Then
                        Throw New Exception(
                            $"クレジット不足です（必要: {totalAmount:C}, 利用可能: {credit:C}）")
                    End If
                    
                    ' === ステップ5: 注文レコードの作成 ===
                    Dim insertOrderCmd As New SqlCommand(
                        "INSERT INTO Orders (CustomerId, OrderDate, TotalAmount, Status) " &
                        "VALUES (@CustomerId, @OrderDate, @TotalAmount, @Status); " &
                        "SELECT SCOPE_IDENTITY();",
                        conn, transaction)
                    insertOrderCmd.Parameters.AddWithValue("@CustomerId", customerId)
                    insertOrderCmd.Parameters.AddWithValue("@OrderDate", DateTime.Now)
                    insertOrderCmd.Parameters.AddWithValue("@TotalAmount", totalAmount)
                    insertOrderCmd.Parameters.AddWithValue("@Status", "確定")
                    
                    Dim orderId As Integer = Convert.ToInt32(insertOrderCmd.ExecuteScalar())
                    
                    ' === ステップ6: 注文明細の作成 ===
                    For Each item In orderItems
                        Dim insertDetailCmd As New SqlCommand(
                            "INSERT INTO OrderDetails " &
                            "(OrderId, ProductId, Quantity, UnitPrice) " &
                            "VALUES (@OrderId, @ProductId, @Quantity, @UnitPrice)",
                            conn, transaction)
                        insertDetailCmd.Parameters.AddWithValue("@OrderId", orderId)
                        insertDetailCmd.Parameters.AddWithValue("@ProductId", item.ProductId)
                        insertDetailCmd.Parameters.AddWithValue("@Quantity", item.Quantity)
                        insertDetailCmd.Parameters.AddWithValue("@UnitPrice", item.Price)
                        insertDetailCmd.ExecuteNonQuery()
                    Next
                    
                    ' === ステップ7: 顧客のクレジット更新 ===
                    Dim updateCreditCmd As New SqlCommand(
                        "UPDATE Customers SET Credit = Credit - @Amount " &
                        "WHERE CustomerId = @CustomerId",
                        conn, transaction)
                    updateCreditCmd.Parameters.AddWithValue("@Amount", totalAmount)
                    updateCreditCmd.Parameters.AddWithValue("@CustomerId", customerId)
                    updateCreditCmd.ExecuteNonQuery()
                    
                    ' === コミット ===
                    transaction.Commit()
                    Return orderId
                    
                Catch ex As Exception
                    ' === ロールバック ===
                    transaction.Rollback()
                    Throw New Exception($"注文処理に失敗: {ex.Message}", ex)
                End Try
            End Using
        End Using
    End Function
End Class

Public Class OrderItem
    Public Property ProductId As Integer
    Public Property Quantity As Integer
    Public Property Price As Decimal
End Class
```

### 実例2: 銀行口座の送金処理

```vb.net
Public Class AccountService
    Private ReadOnly connectionString As String
    
    Public Sub New(connString As String)
        Me.connectionString = connString
    End Sub
    
    ''' <summary>
    ''' 口座間送金を実行する
    ''' </summary>
    Public Sub TransferMoney(fromAccountId As Integer,
                            toAccountId As Integer,
                            amount As Decimal)
        
        ' === 入力検証 ===
        If amount <= 0 Then
            Throw New ArgumentException("送金額は正の値である必要があります")
        End If
        
        If fromAccountId = toAccountId Then
            Throw New ArgumentException("同じ口座への送金はできません")
        End If
        
        Using conn As New SqlConnection(connectionString)
            conn.Open()
            Using transaction = conn.BeginTransaction()
                Try
                    ' === ステップ1: 送金元の残高確認 ===
                    Dim checkBalanceCmd As New SqlCommand(
                        "SELECT Balance, AccountStatus FROM Accounts " &
                        "WHERE AccountId = @AccountId",
                        conn, transaction)
                    checkBalanceCmd.Parameters.AddWithValue("@AccountId", fromAccountId)
                    
                    Dim fromBalance As Decimal
                    Dim fromStatus As String
                    
                    Using reader = checkBalanceCmd.ExecuteReader()
                        If Not reader.Read() Then
                            Throw New Exception("送金元口座が見つかりません")
                        End If
                        fromBalance = Convert.ToDecimal(reader("Balance"))
                        fromStatus = reader("AccountStatus").ToString()
                    End Using
                    
                    ' 口座状態のチェック
                    If fromStatus <> "Active" Then
                        Throw New Exception("送金元口座が利用できません")
                    End If
                    
                    ' 残高チェック
                    If fromBalance < amount Then
                        Throw New Exception(
                            $"残高不足です（残高: {fromBalance:C}, 送金額: {amount:C}）")
                    End If
                    
                    ' === ステップ2: 送金先の確認 ===
                    Dim checkToAccountCmd As New SqlCommand(
                        "SELECT AccountStatus FROM Accounts WHERE AccountId = @AccountId",
                        conn, transaction)
                    checkToAccountCmd.Parameters.AddWithValue("@AccountId", toAccountId)
                    
                    Dim toStatus As Object = checkToAccountCmd.ExecuteScalar()
                    If toStatus Is Nothing Then
                        Throw New Exception("送金先口座が見つかりません")
                    End If
                    
                    If toStatus.ToString() <> "Active" Then
                        Throw New Exception("送金先口座が利用できません")
                    End If
                    
                    ' === ステップ3: 送金元から引き落とし ===
                    Dim debitCmd As New SqlCommand(
                        "UPDATE Accounts " &
                        "SET Balance = Balance - @Amount, UpdatedAt = @UpdatedAt " &
                        "WHERE AccountId = @AccountId",
                        conn, transaction)
                    debitCmd.Parameters.AddWithValue("@Amount", amount)
                    debitCmd.Parameters.AddWithValue("@UpdatedAt", DateTime.Now)
                    debitCmd.Parameters.AddWithValue("@AccountId", fromAccountId)
                    
                    Dim debitRows = debitCmd.ExecuteNonQuery()
                    If debitRows = 0 Then
                        Throw New Exception("送金元からの引き落としに失敗しました")
                    End If
                    
                    ' === ステップ4: 送金先に入金 ===
                    Dim creditCmd As New SqlCommand(
                        "UPDATE Accounts " &
                        "SET Balance = Balance + @Amount, UpdatedAt = @UpdatedAt " &
                        "WHERE AccountId = @AccountId",
                        conn, transaction)
                    creditCmd.Parameters.AddWithValue("@Amount", amount)
                    creditCmd.Parameters.AddWithValue("@UpdatedAt", DateTime.Now)
                    creditCmd.Parameters.AddWithValue("@AccountId", toAccountId)
                    
                    Dim creditRows = creditCmd.ExecuteNonQuery()
                    If creditRows = 0 Then
                        Throw New Exception("送金先への入金に失敗しました")
                    End If
                    
                    ' === ステップ5: トランザクション履歴の記録 ===
                    Dim logCmd As New SqlCommand(
                        "INSERT INTO TransactionLog " &
                        "(FromAccountId, ToAccountId, Amount, TransactionDate, Status) " &
                        "VALUES (@FromAccountId, @ToAccountId, @Amount, @TransactionDate, @Status)",
                        conn, transaction)
                    logCmd.Parameters.AddWithValue("@FromAccountId", fromAccountId)
                    logCmd.Parameters.AddWithValue("@ToAccountId", toAccountId)
                    logCmd.Parameters.AddWithValue("@Amount", amount)
                    logCmd.Parameters.AddWithValue("@TransactionDate", DateTime.Now)
                    logCmd.Parameters.AddWithValue("@Status", "完了")
                    logCmd.ExecuteNonQuery()
                    
                    ' === コミット ===
                    transaction.Commit()
                    
                Catch ex As Exception
                    ' === ロールバック ===
                    transaction.Rollback()
                    
                    ' エラーログの記録（オプション）
                    LogTransactionError(fromAccountId, toAccountId, amount, ex.Message)
                    
                    Throw New Exception($"送金処理に失敗: {ex.Message}", ex)
                End Try
            End Using
        End Using
    End Sub
    
    Private Sub LogTransactionError(fromId As Integer, toId As Integer,
                                   amount As Decimal, errorMessage As String)
        ' エラーログをファイルやDBに記録
        Console.WriteLine($"[ERROR] 送金失敗 - From:{fromId}, To:{toId}, " &
                         $"Amount:{amount:C}, Error:{errorMessage}")
    End Sub
End Class
```

### 実例3: ユーザー登録処理

```vb.net
Public Class UserService
    Private ReadOnly connectionString As String
    
    Public Sub New(connString As String)
        Me.connectionString = connString
    End Sub
    
    ''' <summary>
    ''' 新規ユーザーを登録する
    ''' </summary>
    Public Function RegisterUser(userName As String,
                                email As String,
                                password As String) As Integer
        
        Using conn As New SqlConnection(connectionString)
            conn.Open()
            Using transaction = conn.BeginTransaction()
                Try
                    ' === ステップ1: 入力検証 ===
                    If String.IsNullOrWhiteSpace(userName) Then
                        Throw New ArgumentException("ユーザー名は必須です")
                    End If
                    
                    If String.IsNullOrWhiteSpace(email) Then
                        Throw New ArgumentException("メールアドレスは必須です")
                    End If
                    
                    If password.Length < 8 Then
                        Throw New ArgumentException("パスワードは8文字以上必要です")
                    End If
                    
                    ' === ステップ2: メールアドレスの重複チェック ===
                    Dim checkEmailCmd As New SqlCommand(
                        "SELECT COUNT(*) FROM Users WHERE Email = @Email",
                        conn, transaction)
                    checkEmailCmd.Parameters.AddWithValue("@Email", email)
                    
                    Dim emailCount As Integer = Convert.ToInt32(checkEmailCmd.ExecuteScalar())
                    If emailCount > 0 Then
                        Throw New Exception("このメールアドレスは既に登録されています")
                    End If
                    
                    ' === ステップ3: ユーザー名の重複チェック ===
                    Dim checkUserNameCmd As New SqlCommand(
                        "SELECT COUNT(*) FROM Users WHERE UserName = @UserName",
                        conn, transaction)
                    checkUserNameCmd.Parameters.AddWithValue("@UserName", userName)
                    
                    Dim userNameCount As Integer = Convert.ToInt32(checkUserNameCmd.ExecuteScalar())
                    If userNameCount > 0 Then
                        Throw New Exception("このユーザー名は既に使用されています")
                    End If
                    
                    ' === ステップ4: パスワードのハッシュ化 ===
                    Dim passwordHash As String = HashPassword(password)
                    
                    ' === ステップ5: ユーザーレコードの作成 ===
                    Dim insertUserCmd As New SqlCommand(
                        "INSERT INTO Users (UserName, Email, PasswordHash, CreatedAt, Status) " &
                        "VALUES (@UserName, @Email, @PasswordHash, @CreatedAt, @Status); " &
                        "SELECT SCOPE_IDENTITY();",
                        conn, transaction)
                    insertUserCmd.Parameters.AddWithValue("@UserName", userName)
                    insertUserCmd.Parameters.AddWithValue("@Email", email)
                    insertUserCmd.Parameters.AddWithValue("@PasswordHash", passwordHash)
                    insertUserCmd.Parameters.AddWithValue("@CreatedAt", DateTime.Now)
                    insertUserCmd.Parameters.AddWithValue("@Status", "Active")
                    
                    Dim userId As Integer = Convert.ToInt32(insertUserCmd.ExecuteScalar())
                    
                    ' === ステップ6: ユーザープロフィールの初期化 ===
                    Dim insertProfileCmd As New SqlCommand(
                        "INSERT INTO UserProfiles (UserId, DisplayName, CreatedAt) " &
                        "VALUES (@UserId, @DisplayName, @CreatedAt)",
                        conn, transaction)
                    insertProfileCmd.Parameters.AddWithValue("@UserId", userId)
                    insertProfileCmd.Parameters.AddWithValue("@DisplayName", userName)
                    insertProfileCmd.Parameters.AddWithValue("@CreatedAt", DateTime.Now)
                    insertProfileCmd.ExecuteNonQuery()
                    
                    ' === ステップ7: ウェルカムメール送信（非同期） ===
                    ' 注: メール送信は別スレッドで実行することが多い
                    Task.Run(Sub() SendWelcomeEmail(email, userName))
                    
                    ' === コミット ===
                    transaction.Commit()
                    Return userId
                    
                Catch ex As Exception
                    transaction.Rollback()
                    Throw New Exception($"ユーザー登録に失敗: {ex.Message}", ex)
                End Try
            End Using
        End Using
    End Function
    
    Private Function HashPassword(password As String) As String
        ' 実際にはbcryptなどを使用
        Using sha256 As New System.Security.Cryptography.SHA256Managed()
            Dim bytes = System.Text.Encoding.UTF8.GetBytes(password)
            Dim hash = sha256.ComputeHash(bytes)
            Return Convert.ToBase64String(hash)
        End Using
    End Function
    
    Private Sub SendWelcomeEmail(email As String, userName As String)
        ' ウェルカムメール送信処理
        Console.WriteLine($"ウェルカムメールを {email} に送信しました")
    End Sub
End Class
```

### トランザクションスクリプトのメリット・デメリット

| 項目 | 内容 | 詳細 |
|------|------|------|
| **メリット** | | |
| ✅ シンプル | 手続き型で分かりやすい | 処理の流れが上から下に読める |
| ✅ 学習コスト低 | 初心者でも理解しやすい | 複雑な設計パターンの知識不要 |
| ✅ 開発速度 | 小規模なら早く実装できる | プロトタイプに最適 |
| ✅ デバッグ容易 | 処理が1箇所にまとまっている | ブレークポイントで追いやすい |
| ✅ トランザクション管理明確 | DB操作が見える | BEGIN/COMMIT/ROLLBACKが明示的 |
| **デメリット** | | |
| ❌ コードの重複 | 似た処理が複数箇所に | 保守性の低下 |
| ❌ テスト困難 | 大きなメソッド | モック化が難しい |
| ❌ ビジネスロジック分散 | 再利用しにくい | ドメイン知識が埋もれる |
| ❌ 拡張性低 | 要件変更の影響大 | リファクタリングが困難 |
| ❌ 責任過多 | 1メソッドで全てを行う | 単一責任原則違反 |

### いつ使うべきか

#### ✅ トランザクションスクリプトが適している場合

```vb.net
' 小規模・シンプルな処理
Public Class SimpleReportService
    Public Function GenerateDailySalesReport(targetDate As Date) As String
        ' 1. データ取得
        ' 2. 集計
        ' 3. レポート生成
        ' 単純で変更が少ない処理
    End Function
End Class

' プロトタイプ・MVP
Public Class MVPOrderService
    Public Function QuickCheckout(customerId As Integer, productId As Integer) As Boolean
        ' 最小限の機能で素早く実装
    End Function
End Class

' バッチ処理
Public Class NightlyBatchService
    Public Sub ProcessExpiredOrders()
        ' 定期実行される単純な処理
    End Sub
End Class
```

#### ❌ トランザクションスクリプトが不適切な場合

```vb.net
' 複雑なビジネスルール
Public Class ComplexPricingService
    ' 数十個の価格計算ルール
    ' 頻繁に変更される
    ' → ドメインモデルが適切
End Class

' 大規模システム
Public Class EnterpriseOrderService
    ' 多数の関連処理
    ' 複数チームで開発
    ' → レイヤー化アーキテクチャが必要
End Class
```

---

## トランザクションスクリプトの問題と解決策

### 問題1: コードの重複

#### 問題のあるコード

```vb.net
Public Class OrderService
    Public Function PlaceOrder(...) As Integer
        ' 顧客確認
        Dim customerCmd As New SqlCommand("SELECT Credit FROM Customers...")
        ' ... 20行のコード
        
        ' 在庫チェック
        For Each item In orderItems
            Dim stockCmd As New SqlCommand("SELECT Stock FROM Products...")
            ' ... 15行のコード
        Next
    End Function
    
    Public Function CancelOrder(...) As Boolean
        ' 顧客確認（同じコード！）
        Dim customerCmd As New SqlCommand("SELECT Credit FROM Customers...")
        ' ... 20行のコード
        
        ' 在庫戻し（似たコード）
        For Each item In orderItems
            Dim stockCmd As New SqlCommand("UPDATE Products SET Stock...")
            ' ... 15行のコード
        Next
    End Function
End Class
```

#### 解決策: リポジトリパターン

```vb.net
' ======================================
' データアクセス層の分離
' ======================================

Public Interface ICustomerRepository
    Function GetById(customerId As Integer) As Customer
    Sub UpdateCredit(customerId As Integer, amount As Decimal)
End Interface

Public Interface IProductRepository
    Function GetById(productId As Integer) As Product
    Sub UpdateStock(productId As Integer, quantityChange As Integer)
    Function CheckStock(productId As Integer, requiredQuantity As Integer) As Boolean
End Interface

Public Class CustomerRepository
    Implements ICustomerRepository
    
    Private ReadOnly connectionString As String
    
    Public Sub New(connString As String)
        Me.connectionString = connString
    End Sub
    
    Public Function GetById(customerId As Integer) As Customer _
        Implements ICustomerRepository.GetById
        
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand(
                "SELECT * FROM Customers WHERE CustomerId = @Id", conn)
                cmd.Parameters.AddWithValue("@Id", customerId)
                conn.Open()
                
                Using reader = cmd.ExecuteReader()
                    If reader.Read() Then
                        Return New Customer With {
                            .CustomerId = Convert.ToInt32(reader("CustomerId")),
                            .CustomerName = reader("CustomerName").ToString(),
                            .Credit = Convert.ToDecimal(reader("Credit"))
                        }
                    End If
                End Using
            End Using
        End Using
        Return Nothing
    End Function
    
    Public Sub UpdateCredit(customerId As Integer, amount As Decimal) _
        Implements ICustomerRepository.UpdateCredit
        
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand(
                "UPDATE Customers SET Credit = Credit - @Amount WHERE CustomerId = @Id",
                conn)
                cmd.Parameters.AddWithValue("@Amount", amount)
                cmd.Parameters.AddWithValue("@Id", customerId)
                conn.Open()
                cmd.ExecuteNonQuery()
            End Using
        End Using
    End Sub
End Class

Public Class ProductRepository
    Implements IProductRepository
    
    Private ReadOnly connectionString As String
    
    Public Sub New(connString As String)
        Me.connectionString = connString
    End Sub
    
    Public Function GetById(productId As Integer) As Product _
        Implements IProductRepository.GetById
        
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand(
                "SELECT * FROM Products WHERE ProductId = @Id", conn)
                cmd.Parameters.AddWithValue("@Id", productId)
                conn.Open()
                
                Using reader = cmd.ExecuteReader()
                    If reader.Read() Then
                        Return New Product With {
                            .ProductId = Convert.ToInt32(reader("ProductId")),
                            .ProductName = reader("ProductName").ToString(),
                            .Price = Convert.ToDecimal(reader("Price")),
                            .Stock = Convert.ToInt32(reader("Stock"))
                        }
                    End If
                End Using
            End Using
        End Using
        Return Nothing
    End Function
    
    Public Sub UpdateStock(productId As Integer, quantityChange As Integer) _
        Implements IProductRepository.UpdateStock
        
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand(
                "UPDATE Products SET Stock = Stock + @Change WHERE ProductId = @Id",
                conn)
                cmd.Parameters.AddWithValue("@Change", quantityChange)
                cmd.Parameters.AddWithValue("@Id", productId)
                conn.Open()
                cmd.ExecuteNonQuery()
            End Using
        End Using
    End Sub
    
    Public Function CheckStock(productId As Integer, requiredQuantity As Integer) As Boolean _
        Implements IProductRepository.CheckStock
        
        Using conn As New SqlConnection(connectionString)
            Using cmd As New SqlCommand(
                "SELECT Stock FROM Products WHERE ProductId = @Id", conn)
                cmd.Parameters.AddWithValue("@Id", productId)
                conn.Open()
                
                Dim stock = Convert.ToInt32(cmd.ExecuteScalar())
                Return stock >= requiredQuantity
            End Using
        End Using
    End Function
End Class

' ======================================
' ドメインモデル
' ======================================

Public Class Customer
    Public Property CustomerId As Integer
    Public Property CustomerName As String
    Public Property Credit As Decimal
    
    Public Function CanPurchase(amount As Decimal) As Boolean
        Return Credit >= amount
    End Function
End Class

Public Class Product
    Public Property ProductId As Integer
    Public Property ProductName As String
    Public Property Price As Decimal
    Public Property Stock As Integer
    
    Public Function HasSufficientStock(quantity As Integer) As Boolean
        Return Stock >= quantity
    End Function
End Class

' ======================================
' 改善されたサービス
' ======================================

Public Class ImprovedOrderService
    Private ReadOnly customerRepo As ICustomerRepository
    Private ReadOnly productRepo As IProductRepository
    
    Public Sub New(custRepo As ICustomerRepository, prodRepo As IProductRepository)
        Me.customerRepo = custRepo
        Me.productRepo = prodRepo
    End Sub
    
    Public Function PlaceOrder(customerId As Integer,
                              orderItems As List(Of OrderItemDto)) As Integer
        ' ✅ リポジトリを使用 - コードの重複なし
        Dim customer = customerRepo.GetById(customerId)
        If customer Is Nothing Then
            Throw New Exception("顧客が見つかりません")
        End If
        
        ' ✅ ビジネスロジックがシンプルに
        Dim totalAmount As Decimal = 0
        For Each item In orderItems
            Dim product = productRepo.GetById(item.ProductId)
            If Not product.HasSufficientStock(item.Quantity) Then
                Throw New Exception($"{product.ProductName}の在庫不足")
            End If
            totalAmount += product.Price * item.Quantity
        Next
        
        If Not customer.CanPurchase(totalAmount) Then
            Throw New Exception("クレジット不足")
        End If
        
        ' ... 注文処理
        Return 0 ' 注文ID
    End Function
End Class

Public Class OrderItemDto
    Public Property ProductId As Integer
    Public Property Quantity As Integer
End Class
```

### 問題2: テストの困難さ

#### 問題のあるコード

```vb.net
Public Class OrderService
    Public Function PlaceOrder(...) As Integer
        ' ❌ データベースに直接アクセス
        Using conn As New SqlConnection("Server=...")
            ' テスト時に実DBが必要
            ' テストが遅い
            ' テストデータの準備が大変
        End Using
    End Function
End Class

' テストコード
<TestMethod>
Public Sub TestPlaceOrder()
    ' ❌ 実際のDBが必要
    ' ❌ テストデータのセットアップが複雑
    ' ❌ テスト後のクリーンアップが必要
    Dim service As New OrderService()
    Dim result = service.PlaceOrder(1, items)
End Sub
```

#### 解決策: 依存性の注入（DI）とモック

```vb.net
' ======================================
' テスト可能な設計
' ======================================

Public Class TestableOrderService
    Private ReadOnly customerRepo As ICustomerRepository
    Private ReadOnly productRepo As IProductRepository
    
    ' ✅ 依存性を注入
    Public Sub New(custRepo As ICustomerRepository, prodRepo As IProductRepository)
        Me.customerRepo = custRepo
        Me.productRepo = prodRepo
    End Sub
    
    Public Function PlaceOrder(customerId As Integer,
                              orderItems As List(Of OrderItemDto)) As Integer
        ' リポジトリを使用（モック可能）
        Dim customer = customerRepo.GetById(customerId)
        ' ...
    End Function
End Class

' ======================================
' モックリポジトリ（テスト用）
' ======================================

Public Class MockCustomerRepository
    Implements ICustomerRepository
    
    Private testCustomers As New Dictionary(Of Integer, Customer)
    
    Public Sub AddTestCustomer(customer As Customer)
        testCustomers(customer.CustomerId) = customer
    End Sub
    
    Public Function GetById(customerId As Integer) As Customer _
        Implements ICustomerRepository.GetById
        
        If testCustomers.ContainsKey(customerId) Then
            Return testCustomers(customerId)
        End If
        Return Nothing
    End Function
    
    Public Sub UpdateCredit(customerId As Integer, amount As Decimal) _
        Implements ICustomerRepository.UpdateCredit
        
        If testCustomers.ContainsKey(customerId) Then
            testCustomers(customerId).Credit -= amount
        End If
    End Sub
End Class

' ======================================
' ユニットテスト
' ======================================

<TestClass>
Public Class OrderServiceTests
    
    <TestMethod>
    Public Sub PlaceOrder_正常系_注文IDが返される()
        ' Arrange（準備）
        Dim mockCustomerRepo As New MockCustomerRepository()
        mockCustomerRepo.AddTestCustomer(New Customer With {
            .CustomerId = 1,
            .CustomerName = "テスト太郎",
            .Credit = 10000
        })
        
        Dim mockProductRepo As New MockProductRepository()
        mockProductRepo.AddTestProduct(New Product With {
            .ProductId = 101,
            .ProductName = "テスト商品",
            .Price = 1000,
            .Stock = 50
        })
        
        Dim service As New TestableOrderService(mockCustomerRepo, mockProductRepo)
        
        Dim orderItems As New List(Of OrderItemDto) From {
            New OrderItemDto With {.ProductId = 101, .Quantity = 2}
        }
        
        ' Act（実行）
        Dim orderId = service.PlaceOrder(1, orderItems)
        
        ' Assert（検証）
        Assert.IsTrue(orderId > 0)
    End Sub
    
    <TestMethod>
    <ExpectedException(GetType(Exception))>
    Public Sub PlaceOrder_在庫不足_例外が発生()
        ' Arrange
        Dim mockCustomerRepo As New MockCustomerRepository()
        mockCustomerRepo.AddTestCustomer(New Customer With {
            .CustomerId = 1,
            .Credit = 10000
        })
        
        Dim mockProductRepo As New MockProductRepository()
        mockProductRepo.AddTestProduct(New Product With {
            .ProductId = 101,
            .Stock = 1  ' ✅ 在庫不足の状態
        })
        
        Dim service As New TestableOrderService(mockCustomerRepo, mockProductRepo)
        
        Dim orderItems As New List(Of OrderItemDto) From {
            New OrderItemDto With {.ProductId = 101, .Quantity = 5}  ' ✅ 在庫以上
        }
        
        ' Act & Assert
        service.PlaceOrder(1, orderItems)  ' ✅ 例外が発生することを期待
    End Sub
    
    <TestMethod>
    <ExpectedException(GetType(Exception))>
    Public Sub PlaceOrder_クレジット不足_例外が発生()
        ' Arrange
        Dim mockCustomerRepo As New MockCustomerRepository()
        mockCustomerRepo.AddTestCustomer(New Customer With {
            .CustomerId = 1,
            .Credit = 100  ' ✅ 少額のクレジット
        })
        
        Dim mockProductRepo As New MockProductRepository()
        mockProductRepo.AddTestProduct(New Product With {
            .ProductId = 101,
            .Price = 1000,  ' ✅ 高額商品
            .Stock = 50
        })
        
        Dim service As New TestableOrderService(mockCustomerRepo, mockProductRepo)
        
        Dim orderItems As New List(Of OrderItemDto) From {
            New OrderItemDto With {.ProductId = 101, .Quantity = 2}
        }
        
        ' Act & Assert
        service.PlaceOrder(1, orderItems)  ' ✅ クレジット不足で例外
    End Sub
End Class
```

### 問題3: トランザクション管理の複雑さ

#### 解決策: Unit of Work パターン

```vb.net
' ======================================
' Unit of Work パターン
' ======================================

Public Interface IUnitOfWork
    Inherits IDisposable
    Sub BeginTransaction()
    Sub Commit()
    Sub Rollback()
    ReadOnly Property Connection As SqlConnection
    ReadOnly Property Transaction As SqlTransaction
End Interface

Public Class UnitOfWork
    Implements IUnitOfWork
    
    Private _connection As SqlConnection
    Private _transaction As SqlTransaction
    Private _disposed As Boolean = False
    
    Public Sub New(connectionString As String)
        _connection = New SqlConnection(connectionString)
    End Sub
    
    Public Sub BeginTransaction() Implements IUnitOfWork.BeginTransaction
        If _connection.State <> ConnectionState.Open Then
            _connection.Open()
        End If
        _transaction = _connection.BeginTransaction()
    End Sub
    
    Public Sub Commit() Implements IUnitOfWork.Commit
        If _transaction IsNot Nothing Then
            _transaction.Commit()
            _transaction.Dispose()
            _transaction = Nothing
        End If
    End Sub
    
    Public Sub Rollback() Implements IUnitOfWork.Rollback
        If _transaction IsNot Nothing Then
            _transaction.Rollback()
            _transaction.Dispose()
            _transaction = Nothing
        End If
    End Sub
    
    Public ReadOnly Property Connection As SqlConnection _
        Implements IUnitOfWork.Connection
        Get
            Return _connection
        End Get
    End Property
    
    Public ReadOnly Property Transaction As SqlTransaction _
        Implements IUnitOfWork.Transaction
        Get
            Return _transaction
        End Get
    End Property
    
    Protected Overridable Sub Dispose(disposing As Boolean)
        If Not _disposed Then
            If disposing Then
                _transaction?.Dispose()
                _connection?.Dispose()
            End If
            _disposed = True
        End If
    End Sub
    
    Public Sub Dispose() Implements IDisposable.Dispose
        Dispose(True)
        GC.SuppressFinalize(Me)
    End Sub
End Class

' ======================================
' Unit of Work を使用したサービス
' ======================================

Public Class OrderApplicationService
    Private ReadOnly customerRepo As ICustomerRepository
    Private ReadOnly productRepo As IProductRepository
    Private ReadOnly orderRepo As IOrderRepository
    Private ReadOnly unitOfWork As IUnitOfWork
    
    Public Sub New(custRepo As ICustomerRepository,
                   prodRepo As IProductRepository,
                   ordRepo As IOrderRepository,
                   uow As IUnitOfWork)
        Me.customerRepo = custRepo
        Me.productRepo = prodRepo
        Me.orderRepo = ordRepo
        Me.unitOfWork = uow
    End Sub
    
    Public Function PlaceOrder(customerId As Integer,
                              orderItems As List(Of OrderItemDto)) As Integer
        Try
            ' ✅ トランザクション開始
            unitOfWork.BeginTransaction()
            
            ' ビジネスロジック
            Dim customer = customerRepo.GetById(customerId)
            ValidateCustomer(customer)
            
            Dim order = CreateOrder(customerId, orderItems)
            ValidateOrder(order, customer)
            
            ' データ保存
            Dim orderId = orderRepo.Save(order)
            UpdateInventory(orderItems)
            customerRepo.UpdateCredit(customerId, order.TotalAmount)
            
            ' ✅ コミット
            unitOfWork.Commit()
            Return orderId
            
        Catch ex As Exception
            ' ✅ ロールバック
            unitOfWork.Rollback()
            Throw New ApplicationException($"注文処理失敗: {ex.Message}", ex)
        End Try
    End Function
    
    Private Sub ValidateCustomer(customer As Customer)
        If customer Is Nothing Then
            Throw New Exception("顧客が見つかりません")
        End If
    End Sub
    
    Private Function CreateOrder(customerId As Integer,
                                 items As List(Of OrderItemDto)) As Order
        ' 注文オブジェクトの作成
        Return New Order()
    End Function
    
    Private Sub ValidateOrder(order As Order, customer As Customer)
        If Not customer.CanPurchase(order.TotalAmount) Then
            Throw New Exception("クレジット不足")
        End If
    End Sub
    
    Private Sub UpdateInventory(items As List(Of OrderItemDto))
        For Each item In items
            productRepo.UpdateStock(item.ProductId, -item.Quantity)
        Next
    End Sub
End Class
```

### 問題4: ビジネスロジックの分散

#### 解決策: ドメインサービスとバリデーション層

```vb.net
' ======================================
' バリデーション層
' ======================================

Public Class OrderValidator
    Private ReadOnly customerRepo As ICustomerRepository
    Private ReadOnly productRepo As IProductRepository
    
    Public Sub New(custRepo As ICustomerRepository, prodRepo As IProductRepository)
        Me.customerRepo = custRepo
        Me.productRepo = prodRepo
    End Sub
    
    Public Function Validate(customerId As Integer,
                            orderItems As List(Of OrderItemDto)) As ValidationResult
        
        Dim result As New ValidationResult()
        
        ' 顧客検証
        Dim customer = customerRepo.GetById(customerId)
        If customer Is Nothing Then
            result.AddError("顧客が見つかりません")
            Return result  ' 早期リターン
        End If
        
        ' 注文アイテム検証
        If orderItems Is Nothing OrElse orderItems.Count = 0 Then
            result.AddError("注文商品が指定されていません")
            Return result
        End If
        
        ' 各商品の検証
        Dim totalAmount As Decimal = 0
        For Each item In orderItems
            ' 数量チェック
            If item.Quantity <= 0 Then
                result.AddError($"商品ID {item.ProductId}: 数量は1以上必要です")
                Continue For
            End If
            
            ' 商品存在チェック
            Dim product = productRepo.GetById(item.ProductId)
            If product Is Nothing Then
                result.AddError($"商品ID {item.ProductId} が見つかりません")
                Continue For
            End If
            
            ' 在庫チェック
            If Not product.HasSufficientStock(item.Quantity) Then
                result.AddError($"{product.ProductName}: 在庫不足（在庫: {product.Stock}, 必要: {item.Quantity}）")
            End If
            
            totalAmount += product.Price * item.Quantity
        Next
        
        ' クレジットチェック
        If Not customer.CanPurchase(totalAmount) Then
            result.AddError($"クレジット不足（必要: {totalAmount:C}, 利用可能: {customer.Credit:C}）")
        End If
        
        Return result
    End Function
End Class

Public Class ValidationResult
    Private _errors As New List(Of String)
    
    Public ReadOnly Property IsValid As Boolean
        Get
            Return _errors.Count = 0
        End Get
    End Property
    
    Public ReadOnly Property Errors As List(Of String)
        Get
            Return _errors
        End Get
    End Property
    
    Public Sub AddError(errorMessage As String)
        _errors.Add(errorMessage)
    End Sub
    
    Public Function GetErrorMessage() As String
        Return String.Join(Environment.NewLine, _errors)
    End Function
End Class

' ======================================
' ドメインサービス
' ======================================

Public Class OrderDomainService
    Private ReadOnly productRepo As IProductRepository
    Private ReadOnly customerRepo As ICustomerRepository
    
    Public Sub New(prodRepo As IProductRepository, custRepo As ICustomerRepository)
        Me.productRepo = prodRepo
        Me.customerRepo = custRepo
    End Sub
    
    ''' <summary>
    ''' 注文を作成し、在庫とクレジットを更新する
    ''' </summary>
    Public Function ProcessOrder(customerId As Integer,
                                orderItems As List(Of OrderItemDto)) As Order
        
        Dim order As New Order With {
            .CustomerId = customerId,
            .OrderDate = DateTime.Now,
            .Status = "処理中"
        }
        
        ' 各商品の処理
        For Each item In orderItems
            Dim product = productRepo.GetById(item.ProductId)
            
            ' 在庫を引き当てる
            product.Stock -= item.Quantity
            productRepo.UpdateStock(product.ProductId, -item.Quantity)
            
            ' 注文明細を追加
            order.AddItem(product, item.Quantity)
        Next
        
        ' 顧客のクレジットを更新
        Dim customer = customerRepo.GetById(customerId)
        customer.Credit -= order.TotalAmount
        customerRepo.UpdateCredit(customerId, order.TotalAmount)
        
        order.Status = "確定"
        Return order
    End Function
End Class

Public Class Order
    Public Property OrderId As Integer
    Public Property CustomerId As Integer
    Public Property OrderDate As DateTime
    Public Property Status As String
    Private _items As New List(Of OrderDetail)
    
    Public ReadOnly Property Items As List(Of OrderDetail)
        Get
            Return _items
        End Get
    End Property
    
    Public ReadOnly Property TotalAmount As Decimal
        Get
            Return _items.Sum(Function(x) x.Subtotal)
        End Get
    End Property
    
    Public Sub AddItem(product As Product, quantity As Integer)
        _items.Add(New OrderDetail With {
            .ProductId = product.ProductId,
            .ProductName = product.ProductName,
            .Quantity = quantity,
            .UnitPrice = product.Price
        })
    End Sub
End Class

Public Class OrderDetail
    Public Property ProductId As Integer
    Public Property ProductName As String
    Public Property Quantity As Integer
    Public Property UnitPrice As Decimal
    
    Public ReadOnly Property Subtotal As Decimal
        Get
            Return Quantity * UnitPrice
        End Get
    End Property
End Class

' ======================================
' アプリケーションサービス（統合）
' ======================================

Public Class ImprovedOrderApplicationService
    Private ReadOnly validator As OrderValidator
    Private ReadOnly domainService As OrderDomainService
    Private ReadOnly orderRepo As IOrderRepository
    Private ReadOnly unitOfWork As IUnitOfWork
    
    Public Sub New(val As OrderValidator,
                   domSvc As OrderDomainService,
                   ordRepo As IOrderRepository,
                   uow As IUnitOfWork)
        Me.validator = val
        Me.domainService = domSvc
        Me.orderRepo = ordRepo
        Me.unitOfWork = uow
    End Sub
    
    Public Function PlaceOrder(customerId As Integer,
                              orderItems As List(Of OrderItemDto)) As OrderResult
        
        ' ✅ 1. バリデーション
        Dim validationResult = validator.Validate(customerId, orderItems)
        If Not validationResult.IsValid Then
            Return New OrderResult With {
                .Success = False,
                .ErrorMessage = validationResult.GetErrorMessage()
            }
        End If
        
        Try
            ' ✅ 2. トランザクション開始
            unitOfWork.BeginTransaction()
            
            ' ✅ 3. ドメインロジック実行
            Dim order = domainService.ProcessOrder(customerId, orderItems)
            
            ' ✅ 4. データ保存
            Dim orderId = orderRepo.Save(order)
            
            ' ✅ 5. コミット
            unitOfWork.Commit()
            
            Return New OrderResult With {
                .Success = True,
                .OrderId = orderId
            }
            
        Catch ex As Exception
            unitOfWork.Rollback()
            
            Return New OrderResult With {
                .Success = False,
                .ErrorMessage = $"注文処理に失敗しました: {ex.Message}"
            }
        End Try
    End Function
End Class

Public Class OrderResult
    Public Property Success As Boolean
    Public Property OrderId As Integer
    Public Property ErrorMessage As String
End Class
```

## まとめ: アーキテクチャの進化

### ステップ1: トランザクションスクリプト（初期）
```
[プレゼンテーション層]
        ↓
[トランザクションスクリプト]
  - PlaceOrder()
  - CancelOrder()
        ↓
   [データベース]
```

**特徴:**
- シンプル
- 小規模向け
- 保守性低い

### ステップ2: リポジトリ導入（中期）
```
[プレゼンテーション層]
        ↓
  [サービス層]
        ↓
 [リポジトリ層]
        ↓
   [データベース]
```

**特徴:**
- データアクセス分離
- テスト可能
- 中規模向け

### ステップ3: レイヤー化アーキテクチャ（成熟期）
```
[プレゼンテーション層]
        ↓
[アプリケーション層]
  - ユースケース
  - バリデーション
        ↓
  [ドメイン層]
  - ビジネスロジック
  - ドメインモデル
        ↓
[インフラストラクチャ層]
  - リポジトリ実装
  - データベース
```

**特徴:**
- 責任分離明確
- 高い保守性
- 大規模向け

### 推奨される移行パス

| プロジェクト規模 | 推奨アーキテクチャ | 複雑度 |
|------------------|-------------------|--------|
| 小規模（〜10画面） | トランザクションスクリプト | ★☆☆☆☆ |
| 中規模（10〜50画面） | リポジトリ + サービス層 | ★★★☆☆ |
| 大規模（50画面〜） | レイヤー化 + DDD | ★★★★★ |

**重要なポイント:**
- 最初から完璧を目指さない
- 段階的にリファクタリング
- チームのスキルレベルに合わせる
- ビジネス価値を優先